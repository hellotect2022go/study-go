# Step 2: io ν¨ν‚¤μ§€ ν•µμ‹¬ μΈν„°νμ΄μ¤

## π― ν•™μµ λ©ν‘
- `io.Reader` μΈν„°νμ΄μ¤ μ™„μ „ μ΄ν•΄
- `io.Writer` μΈν„°νμ΄μ¤ μ™„μ „ μ΄ν•΄
- EOF(End of File) μ²λ¦¬ ν¨ν„΄ μµνκΈ°
- μΈν„°νμ΄μ¤μ κ°•λ ¥ν•¨ μ²΄ν—ν•κΈ°

## π“ Goμ io ν¨ν‚¤μ§€

Go μ–Έμ–΄μ `io` ν¨ν‚¤μ§€λ” μ…μ¶λ ¥ μ‘μ—…μ ν•µμ‹¬μ…λ‹λ‹¤.
μ •λ§ κ°„λ‹¨ν•λ©΄μ„λ„ κ°•λ ¥ν• λ‘ κ°€μ§€ μΈν„°νμ΄μ¤λ¥Ό μ κ³µν•©λ‹λ‹¤.

## π”‘ ν•µμ‹¬ μΈν„°νμ΄μ¤ 2κ°€μ§€

### 1. io.Reader - λ°μ΄ν„° μ½κΈ°

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

**νΉμ§•**:
- λ‹¨ ν•λ‚μ λ©”μ„λ“λ§ μ΅΄μ¬
- λ°”μ΄νΈ μ¬λΌμ΄μ¤λ¥Ό λ°›μ•„ λ°μ΄ν„°λ¥Ό μ±„μ›€
- μ½μ€ λ°”μ΄νΈ μμ™€ μ—λ¬λ¥Ό λ°ν™

**μ¥μ **:
- νμΌ, λ„¤νΈμ›ν¬, λ©”λ¨λ¦¬ λ²„νΌ λ¨λ‘ κ°™μ€ λ°©μ‹μΌλ΅ μ²λ¦¬
- μ•”νΈν™”λ μ¤νΈλ¦Όλ„ λ™μΌν•κ² λ‹¤λ£Έ
- μΈν„°νμ΄μ¤ μ΅°ν•©μΌλ΅ κ°•λ ¥ν• κΈ°λ¥ κµ¬ν„

### 2. io.Writer - λ°μ΄ν„° μ“°κΈ°

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

**νΉμ§•**:
- λ‹¨ ν•λ‚μ λ©”μ„λ“λ§ μ΅΄μ¬
- λ°”μ΄νΈ μ¬λΌμ΄μ¤λ¥Ό λ°›μ•„ μ“°κΈ°
- μ“΄ λ°”μ΄νΈ μμ™€ μ—λ¬λ¥Ό λ°ν™

**μ¥μ **:
- νμΌ, λ„¤νΈμ›ν¬, ν‘μ¤€μ¶λ ¥ λ¨λ‘ κ°™μ€ λ°©μ‹
- λ²„νΌ, μ••μ¶•, μ•”νΈν™” λ μ΄μ–΄ μ‰½κ² μ¶”κ°€

## π’΅ μ™ μ΄λ ‡κ² λ‹¨μν• κΉ?

Goμ μ² ν•™: **"μ‘κ³  λ…ν™•ν• μΈν„°νμ΄μ¤"**

### μ¥μ 
1. **λ°°μ°κΈ° μ‰¬μ›€**: λ©”μ„λ“κ°€ ν•λ‚λΏ
2. **μ΅°ν•© κ°€λ¥**: μ—¬λ¬ Reader/Writerλ¥Ό λ μ΄μ–΄μ²λΌ μ“κΈ°
3. **λ²”μ©μ„±**: λ¨λ“  μ…μ¶λ ¥μ„ λ™μΌν•κ² μ²λ¦¬
4. **ν…μ¤νΈ μ©μ΄**: Mock κ°μ²΄ λ§λ“¤κΈ° μ‰¬μ›€

## π“– io.Reader μƒμ„Έ λ¶„μ„

### Read λ©”μ„λ“ λ™μ‘
```go
n, err := reader.Read(buffer)
```

**λ§¤κ°λ³€μ**:
- `p []byte`: μ½μ€ λ°μ΄ν„°λ¥Ό μ €μ¥ν•  λ²„νΌ

**λ°ν™κ°’**:
- `n int`: μ‹¤μ λ΅ μ½μ€ λ°”μ΄νΈ μ (0 ~ len(p))
- `err error`: μ—λ¬ (μ—†μΌλ©΄ nil, λμ΄λ©΄ io.EOF)

### μ¤‘μ” κ·μΉ™

1. **nμ€ len(p) μ΄ν•**
   - λ²„νΌλ³΄λ‹¤ λ§μ΄ μ½μ„ μ μ—†μ

2. **n > 0μ΄λ©΄ errκ°€ nilμΌ μ μμ**
   - λ°μ΄ν„°λ¥Ό μ½μ—μ§€λ§ μ—λ¬λ„ λ°μƒ κ°€λ¥

3. **n == 0μ΄κ³  err == nil**
   - μ•„λ¬΄ μΌλ„ μΌμ–΄λ‚μ§€ μ•μ (λ‹¤μ‹ μ‹λ„)

4. **err == io.EOF**
   - νμΌ λμ— λ„λ‹¬
   - λ” μ΄μƒ μ½μ„ λ°μ΄ν„° μ—†μ

### μ½κΈ° ν¨ν„΄

```go
buffer := make([]byte, ν¬κΈ°)

for {
    n, err := reader.Read(buffer)
    
    // μ½μ€ λ°μ΄ν„° μ²λ¦¬
    if n > 0 {
        // buffer[:n] μ‚¬μ©
        process(buffer[:n])
    }
    
    // μ—λ¬ μ²λ¦¬
    if err == io.EOF {
        break  // μ •μƒ μΆ…λ£
    }
    if err != nil {
        return err  // μ—λ¬ λ°μƒ
    }
}
```

## βοΈ io.Writer μƒμ„Έ λ¶„μ„

### Write λ©”μ„λ“ λ™μ‘
```go
n, err := writer.Write(data)
```

**λ§¤κ°λ³€μ**:
- `p []byte`: μ“Έ λ°μ΄ν„°

**λ°ν™κ°’**:
- `n int`: μ‹¤μ λ΅ μ“΄ λ°”μ΄νΈ μ
- `err error`: μ—λ¬ (μ—†μΌλ©΄ nil)

### μ¤‘μ” κ·μΉ™

1. **n == len(p)μ—¬μ•Ό μ„±κ³µ**
   - μ „μ²΄λ¥Ό λ‹¤ μ“°μ§€ λ»ν•λ©΄ μ—λ¬

2. **μ—λ¬κ°€ nilμ΄ μ•„λ‹λ©΄ n < len(p)**
   - μΌλ¶€λ§ μ“΄ κ²½μ° μ—λ¬ λ°ν™

3. **μ λ€ io.EOFλ¥Ό λ°ν™ν•μ§€ μ•μ**
   - Writerλ” λμ΄ μ—†μ

## π¨ io.Reader κµ¬ν„μ²΄ μμ‹

Go ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ μ—¬λ¬ νƒ€μ…μ΄ io.Readerλ¥Ό κµ¬ν„ν•©λ‹λ‹¤:

- `os.File` - νμΌ
- `strings.Reader` - λ¬Έμμ—΄
- `bytes.Buffer` - λ©”λ¨λ¦¬ λ²„νΌ
- `net.Conn` - λ„¤νΈμ›ν¬ μ—°κ²°
- `compress/gzip.Reader` - gzip μ¤νΈλ¦Ό
- `crypto/cipher.StreamReader` - μ•”νΈν™” μ¤νΈλ¦Ό

**λ¨λ‘ κ°™μ€ λ°©μ‹μΌλ΅ μ‚¬μ© κ°€λ¥!** β¨

## π¨ io.Writer κµ¬ν„μ²΄ μμ‹

- `os.File` - νμΌ
- `os.Stdout` - ν‘μ¤€ μ¶λ ¥
- `bytes.Buffer` - λ©”λ¨λ¦¬ λ²„νΌ
- `net.Conn` - λ„¤νΈμ›ν¬ μ—°κ²°
- `compress/gzip.Writer` - gzip μ••μ¶•
- `crypto/cipher.StreamWriter` - μ•”νΈν™”

## π”„ μΈν„°νμ΄μ¤ μ΅°ν•©μ ν

```go
νμΌ Reader
  β†“
gzip Reader (μ••μ¶• ν•΄μ )
  β†“
μ•”νΈν™” Reader (λ³µνΈν™”)
  β†“
λ°μ΄ν„° μ²λ¦¬
```

κ° λ μ΄μ–΄κ°€ `io.Reader`λ¥Ό κµ¬ν„ν•λ―€λ΅ μμ λ΅­κ² μ΅°ν•© κ°€λ¥!

## π“ μ‹¤μµ κ³Όμ 

### κ³Όμ  1: Read λ™μ‘ μ΄ν•΄ν•κΈ°

10λ°”μ΄νΈ λ²„νΌλ΅ "Hello, World!"λ¥Ό μ½μΌλ©΄?

**μμƒ κ²°κ³Ό**:
- 1μ°¨: "Hello, Wor" (10λ°”μ΄νΈ)
- 2μ°¨: "ld!" (3λ°”μ΄νΈ)
- 3μ°¨: io.EOF

### κ³Όμ  2: EOF μ²λ¦¬

λ‹¤μ μ½”λ“μ—μ„ μ‹¤μλ”?

```go
for {
    n, err := reader.Read(buffer)
    if err != nil {
        return err  // β μλ»λ¨!
    }
    process(buffer[:n])
}
```

**λ¬Έμ μ **: 
- EOFλ„ μ—λ¬λ΅ μ²λ¦¬ν•μ—¬ μ •μƒ μΆ…λ£ν•μ§€ λ»ν•¨
- μ½μ€ λ°μ΄ν„°(n > 0)λ¥Ό μ²λ¦¬ν•μ§€ λ»ν•  μ μμ

**μ¬λ°”λ¥Έ μ½”λ“**:
```go
for {
    n, err := reader.Read(buffer)
    if n > 0 {
        process(buffer[:n])  // λ¨Όμ € λ°μ΄ν„° μ²λ¦¬
    }
    if err == io.EOF {
        break  // μ •μƒ μΆ…λ£
    }
    if err != nil {
        return err  // μ—λ¬
    }
}
```

### κ³Όμ  3: μΈν„°νμ΄μ¤ μ‚¬κ³ 

λ‹¤μ μ¤‘ io.Readerλ΅ μ²λ¦¬ν•  μ μλ” κ²ƒμ€?

1. νμΌ μ½κΈ°
2. HTTP μ‘λ‹µ λ³Έλ¬Έ
3. ν‚¤λ³΄λ“ μ…λ ¥
4. λ©”λ¨λ¦¬ λ°μ΄ν„°
5. λ°μ΄ν„°λ² μ΄μ¤ μΏΌλ¦¬ κ²°κ³Ό

**μ •λ‹µ**: λ¨λ‘ κ°€λ¥! (io.Readerλ¥Ό κµ¬ν„ν•λ©΄)

## π”‘ ν•µμ‹¬ μ”μ•½

### io.Reader
```go
Read(p []byte) (n int, err error)
```
- λ°μ΄ν„°λ¥Ό μ½λ” μ μΌν• λ°©λ²•
- n: μ½μ€ λ°”μ΄νΈ μ (0 ~ len(p))
- err: io.EOFμ΄λ©΄ λ, nilμ΄λ©΄ κ³„μ†

### io.Writer
```go
Write(p []byte) (n int, err error)
```
- λ°μ΄ν„°λ¥Ό μ“°λ” μ μΌν• λ°©λ²•
- n: μ“΄ λ°”μ΄νΈ μ (n == len(p)μ—¬μ•Ό μ„±κ³µ)
- err: nilμ΄ μ•„λ‹λ©΄ μ‹¤ν¨

### μ½κΈ° ν¨ν„΄
```
λ°λ³µ:
  1. λ°μ΄ν„° μ½κΈ° (n, err)
  2. n > 0μ΄λ©΄ μ²λ¦¬
  3. err == io.EOFλ©΄ μΆ…λ£
  4. err != nilμ΄λ©΄ μ—λ¬ μ²λ¦¬
```

## β΅οΈ λ‹¤μ λ‹¨κ³„

**Step 3: io ν¨ν‚¤μ§€ μ μ©ν• ν•¨μλ“¤**
- `io.Copy()`, `io.CopyN()`, `io.ReadAll()` λ“±
- Readerμ™€ Writerλ¥Ό νΈλ¦¬ν•κ² μ‚¬μ©ν•λ” λ„κµ¬λ“¤

